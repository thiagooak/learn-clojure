---
title: "Writing Functions"
sequence: 3
---

## Objectives

- Define a Clojure function with the `defn` form
- Invoke the function with a REPL
- Give the function a docstring
- Revisit pure and impure functions
- Write a lambda and identify higher order functions
- Identify expressions, bindings, and function return values
- Accept differing numbers of parameters with multi-arity functions
- Accept differing numbers of parameters with variable argument functions
- Destructure function parameters

## Overview

Clojure is a functional programming language. Functions are the building blocks of any program written in Clojure. Learning to write effective functions is foundational to being successful with the Clojure programming language. In this lesson you will learn the basics of how to write functions, how to use functions, and how to assemble functions together to create programs.

## Summary

In this module we've covered the basics of writing functions in Clojure. We've learned to use the `defn` form to write top-level, named functions. And we've learned how to write lambdas, which are often useful as parameters to higher-order functions. We covered docstrings and pure versus impure functions. We explored expressions, bindings, and function return values. We learned how to write functions with variable number of parameters. We learned how to destructure function parameters. And we wrote and invoked different versions of our hello world function by using an interactive Clojure REPL. Along the way we touched on a couple of topics that will be covered in upcoming modules: collections, lists and sequences of data in Clojure; and modeling state changes using Clojure stateful value containers such as atoms and refs.

## Resources

- [Tryclojure.org: Online REPL](https://tryclojure.org/)
- [Namespaces](https://clojure.org/reference/namespaces)
- [Evaluation](https://clojure.org/reference/evaluation)
- https://clojure.org/guides/learn/functions
- [Clojure destructuring](https://clojure.org/guides/destructuring)
